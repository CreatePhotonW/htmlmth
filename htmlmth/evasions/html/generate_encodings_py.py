# Too lazy to create evasions/html/encodings.py by hand


document = ""
document += """from . import TransformFunction, string_to_tfarg_function, mime_type_based_transform, normalized_headers_to_tfarg_function
import htmlmth.mods.http
import htmlmth.mods.html


# This file was generated by generate_encodings_py.py"


"""

# (name of function in custom_encodings.py , name of encoding to place in descriptions)
all_encodings = [
    ("utf_8", "UTF-8"),
    ("utf_16_be", "UTF-16BE"),
    ("utf_16_le", "UTF-16LE"),
    ("utf_7_0", "UTF-7 variant 0"),
    ("utf_7_1", "UTF-7 variant 1"),
    ("utf_7_2", "UTF-7 variant 2"),
    ("utf_7_3", "UTF-7 variant 3"),
    ("utf_7_4", "UTF-7 variant 4"),
    ("utf_7_5", "UTF-7 variant 5"),
    ("utf_7_5_i", "UTF-7 variant 5i"),
]

all_encoding_declarations = [
    "utf-8",
    "utf-16",
    "utf-16be",
    "utf-16le",
    "utf-7",
]

all_bom = [
    ("\xef\xbb\xbf", "utf-8"),
    # ("", "utf-16"),
    ("\xfe\xff", "utf-16be"),
    ("\xff\xfe", "utf-16le"),
    # ("", "utf-7 (variant 0)"), # TODO: the correct variant that'll result in variants 1 OR 2 OR 3 OR 4 & not result in the first character being a random unicode char
    ("\x2b\x2f\x76\x38", "utf-7 (variant 1)"), # messes up the encoding of the first char since the 4th byte of the BOM is dependent on the first char
    ("\x2b\x2f\x76\x39", "utf-7 (variant 2)"), # messes up the encoding of the first char since the 4th byte of the BOM is dependent on the first char
    ("\x2b\x2f\x76\x2b", "utf-7 (variant 3)"), # messes up the encoding of the first char since the 4th byte of the BOM is dependent on the first char
    ("\x2b\x2f\x76\x2f", "utf-7 (variant 4)"), # messes up the encoding of the first char since the 4th byte of the BOM is dependent on the first char
    ("\x2b\x2f\x76\x38\x2d", "utf-7 (variant 5)"),
]

all_mime_types = [
    "text/html",
    "application/xhtml+xml",
    "application/xml",
    "text/xml",
    "text/javascript",
    "text/vbscript"
]



##### NO DECLARED ENCODING #####

description_template = "No encoding declared ;sent encoded as {}"

evasion_template = """# soft assumption that no encoding declared in the document
# soft assumption that encoding has not been declared in HTTP headers
# soft assumption that no BOM present
no_declared_encoding_encoded_as_{0} = TransformFunction("",
                                                     "{1}",
                                                     mime_type_based_transform({{
{2}                                                     }}))
"""

func1_dict_template = "                                                         '{0}': string_to_tfarg_function(lambda x: htmlmth.mods.html.{1}(x.encode('utf-8'))),\n"


for e in all_encodings:
    description = description_template.format(e[1])
    func1_dict = ""
    for m in all_mime_types:
        func1_dict += func1_dict_template.format(m, e[0])
    evasion = evasion_template.format(e[0], description, func1_dict)
    document += evasion + "\n"




##### DECLARE ENCODING IN HTTP HEADER #####

description_template = "declared as {} in http headers ;sent encoded as {}"

evasion_template = """# soft assumption that no encoding declared in the document
# soft assumption that no BOM present
http_declared_{4}_encoded_as_{0} = TransformFunction("",
                                                     "{1}",
                                                     mime_type_based_transform({{
{2}                                                     }}),
                                                     mime_type_based_transform({{
{3}                                                     }}))
"""

func1_dict_template = "                                                         '{0}': normalized_headers_to_tfarg_function(lambda x: htmlmth.mods.http.declare_encoding('{1}', x)),\n"

func2_dict_template = "                                                         '{0}': string_to_tfarg_function(lambda x: htmlmth.mods.html.{1}(x.encode('utf-8'))),\n"


for e in all_encodings:
    for ed in all_encoding_declarations:
        description = description_template.format(ed, e[1])
        func1_dict = ""
        func2_dict = ""
        for m in all_mime_types:
            func1_dict += func1_dict_template.format(m, ed)
        for m in all_mime_types:
            func2_dict += func2_dict_template.format(m, e[0])
        evasion = evasion_template.format(e[0], description, func1_dict, func2_dict, ed.replace('-', '_'))
        document += evasion + "\n"

##### DECLARE ENCODING WITH BOM #####

description_template = "{} BOM ;sent encoded as {}"

evasion_template = """# soft assumption that no encoding declared in the document
# soft assumption that encoding has not been declared in HTTP headers
bom_declared_{4}_encoded_as_{0} = TransformFunction("",
                                                     "{1}",
                                                     mime_type_based_transform({{
{2}                                                     }}),
                                                     mime_type_based_transform({{
{3}                                                     }}))
"""

func1_dict_template = "                                                         '{0}': string_to_tfarg_function(lambda x: htmlmth.mods.html.{1}(x.encode('utf-8'))),\n"

func2_dict_template = "                                                         '{0}': string_to_tfarg_function(lambda x: {1} + str(x)),\n"



for e in all_encodings:
    for bom in all_bom:
        description = description_template.format(bom[1], e[1])
        func1_dict = ""
        func2_dict = ""
        for m in all_mime_types:
            func1_dict += func1_dict_template.format(m, e[0])
        for m in all_mime_types:
            func2_dict += func2_dict_template.format(m, repr(bom[0]))
        evasion = evasion_template.format(e[0], description, func1_dict, func2_dict, bom[1].replace('-', '_').replace(" ", "_").replace("(", "").replace(")", ""))
        document += evasion + "\n"


##### DECLARE ENCODING IN HTTP HEADER AND WITH BOM #####

description_template = "declared as {} in http headers ;{} BOM ;sent encoded as {}"

evasion_template = """# soft assumption that no encoding declared in the document
# soft assumption that encoding has not been declared in HTTP headers
# soft assumption that no BOM present
http_declared_{6}_bom_declared_{5}_encoded_as_{0} = TransformFunction("",
                                                     "{1}",
                                                     mime_type_based_transform({{
{2}                                                     }}),
                                                     mime_type_based_transform({{
{3}                                                     }}),
                                                     mime_type_based_transform({{
{4}                                                     }})
)
"""

func1_dict_template = "                                                         '{0}': string_to_tfarg_function(lambda x: htmlmth.mods.html.{1}(x.encode('utf-8'))),\n"

func2_dict_template = "                                                         '{0}': string_to_tfarg_function(lambda x: {1} + str(x)),\n"

func3_dict_template = "                                                         '{0}': normalized_headers_to_tfarg_function(lambda x: htmlmth.mods.http.declare_encoding('{1}', x)),\n"



for e in all_encodings:
    for ed in all_encoding_declarations:
        for bom in all_bom:
            description = description_template.format(ed, bom[1], e[1])
            func1_dict = ""
            func2_dict = ""
            func3_dict = ""
            for m in all_mime_types:
                func1_dict += func1_dict_template.format(m, e[0])
            for m in all_mime_types:
                func2_dict += func2_dict_template.format(m, repr(bom[0]))
            for m in all_mime_types:
                func3_dict += func3_dict_template.format(m, ed)
            evasion = evasion_template.format(e[0], description, func1_dict, func2_dict, func3_dict, bom[1].replace('-', '_').replace(" ", "_").replace("(", "").replace(")", ""), ed.replace('-', '_'))
            document += evasion + "\n"




##### DECLARE ENCODING IN DOCUMENT #####
# TODO:





print(document)

with open("encodings.py", "w") as f:
    f.write(document)
